using System.Globalization;
using System.Reflection;
namespace SharedFunctions;

/// <summary>
/// this class was generated by Claude via this prompt:
///     create a CSV parsing class that can take a CSV file for each of the record types defined in #file:DataTypes.cs
///     and returns a list of those records. assume that the CSV column names perfectly match the property names defined
///     in the records
/// I only slightly edited it
/// </summary>
public static class CsvParse
{
    public static List<T> ParseCsv<T>(string filePath) where T : class
    {
        if (!File.Exists(filePath))
        {
            throw new FileNotFoundException($"CSV file not found: {filePath}");
        }

        var lines = File.ReadAllLines(filePath);
        if (lines.Length == 0)
        {
            return new List<T>();
        }

        // Parse header to get column names
        var headers = lines[0].Split(',').Select(h => h.Trim().Trim('"')).ToArray();
        var results = new List<T>();

        // Get the constructor for the record type
        var recordType = typeof(T);
        var constructors = recordType.GetConstructors();
        var constructor = constructors.FirstOrDefault();

        if (constructor == null)
        {
            throw new InvalidOperationException($"No constructor found for type {recordType.Name}");
        }

        var parameters = constructor.GetParameters();

        // Process data rows
        for (int i = 1; i < lines.Length; i++)
        {
            var values = ParseCsvLine(lines[i]);
            if (values.Length != headers.Length)
            {
                throw new InvalidDataException($"Row {i + 1}: Expected {headers.Length} columns, found {values.Length}");
            }

            var constructorArgs = new object[parameters.Length];

            for (int j = 0; j < parameters.Length; j++)
            {
                var param = parameters[j];
                var headerIndex = Array.FindIndex(headers, h => h.Equals(param.Name, StringComparison.OrdinalIgnoreCase));

                if (headerIndex == -1)
                {
                    throw new InvalidOperationException($"Column '{param.Name}' not found in CSV headers");
                }

                var cellValue = values[headerIndex].Trim().Trim('"');
                constructorArgs[j] = ConvertValue(cellValue, param.ParameterType);
            }

            var instance = (T)Activator.CreateInstance(recordType, constructorArgs);
            results.Add(instance);
        }

        return results;
    }

    private static string[] ParseCsvLine(string line)
    {
        var values = new List<string>();
        var currentValue = string.Empty;
        var insideQuotes = false;

        for (int i = 0; i < line.Length; i++)
        {
            var currentChar = line[i];

            if (currentChar == '"')
            {
                insideQuotes = !insideQuotes;
            }
            else if (currentChar == ',' && !insideQuotes)
            {
                values.Add(currentValue);
                currentValue = string.Empty;
            }
            else
            {
                currentValue += currentChar;
            }
        }

        values.Add(currentValue); // Add the last value
        return values.ToArray();
    }

    private static object ConvertValue(string value, Type targetType)
    {
        // Handle null/empty values for nullable types
        if (string.IsNullOrWhiteSpace(value) || value.Equals("NULL", StringComparison.OrdinalIgnoreCase))
        {
            if (IsNullable(targetType))
            {
                return null;
            }
            else if (targetType == typeof(string))
            {
                return string.Empty;
            }
            else
            {
                throw new InvalidDataException($"Cannot convert null/empty value to non-nullable type {targetType.Name}");
            }
        }

        // Handle nullable types
        if (IsNullable(targetType))
        {
            targetType = Nullable.GetUnderlyingType(targetType);
        }

        // Convert based on target type
        return targetType.Name switch
        {
            nameof(Int32) => int.Parse(value),
            nameof(Decimal) => decimal.Parse(value, CultureInfo.InvariantCulture),
            nameof(DateTime) => DateTime.Parse(value, CultureInfo.InvariantCulture),
            nameof(String) => value,
            _ => Convert.ChangeType(value, targetType, CultureInfo.InvariantCulture)
        };
    }

    private static bool IsNullable(Type type)
    {
        return type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>);
    }

    // Convenience methods for each record type
    public static List<Account> ParseAccounts(string filePath) => ParseCsv<Account>(filePath);
    public static List<Address> ParseAddresses(string filePath) => ParseCsv<Address>(filePath);
    public static List<Customer> ParseCustomers(string filePath) => ParseCsv<Customer>(filePath);
    public static List<CustomerSegment> ParseCustomerSegments(string filePath) => ParseCsv<CustomerSegment>(filePath);
    public static List<Segment> ParseSegments(string filePath) => ParseCsv<Segment>(filePath);
    public static List<Transaction> ParseTransactions(string filePath) => ParseCsv<Transaction>(filePath);
}